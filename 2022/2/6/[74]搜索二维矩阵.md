>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：
>每行中的整数从左到右按升序排列。
>每行的第一个整数大于前一行的最后一个整数。

keywords: 升序，存在目标值
labels: binary sort


My solution 1:
只是在两个维度上先后运用binary search，稍微设计条件即可

```
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        l1 = len(matrix)
        left1,right1 = 0,l1-1
        while left1<right1:
            mid = (left1+right1)//2
            print("left1:{},right1:{}".format(left1,right1))
            if matrix[mid][0]<= target <=matrix[mid][-1]:
                left1=mid
                break
            elif matrix[mid][0] > target:
                print('1')
                right1=mid-1
            elif matrix[mid][-1] <target:
                print('2')
                left1 = mid+1
        if matrix[left1][0]> target or matrix[left1][-1]<target:
            print('not in any list')
            return False
        else:
            nums = matrix[left1]
            l2 = len(nums)
            left2,right2 = 0,l2-1
            while left2<right2:
                mid1 = (left2+right2)//2
                if nums[mid1] == target:
                    return True
                elif nums[mid1]<target:
                    left2=mid1+1
                else:
                    right2=mid1-1
            return nums[left2]==target
```
My solution 2:
拼成一个一维数组然后一次binary search
```
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        if matrix:
            temp = []
            for i in matrix:
                temp+=i
            l=len(temp)

            left2,right2 = 0,l-1
            while left2<right2:
                mid1 = (left2+right2)//2
                if temp[mid1] == target:
                    return True
                elif temp[mid1]<target:
                    left2=mid1+1
                else:
                    right2=mid1-1
            return temp[left2]==target
```
